#variable_points: []
variable_x: 0
variable_y: 0
variable_sum_xy: 0 
variable_sum_x2: 0

gcode:
 	# Calculating linear least squares regression
	#get points an other data from the z_tramming_grid macro
    #list inbound has form [(xpos, z), ....]
    M118 Calculating tilt
     {% set nxy = namespace(sum_xy=0, sum_x2=0) %}
    M118 reading data
    {% set base_vars = printer["gcode_macro Z_TRAMMING_GRID"] %}
    {% set z_screws_distance = base_vars.z_screws_distance %} 
    {% set pitch = base_vars.screw_pitch %} 
    {% set tolerance = base_vars.max_tolerance %}
    {% set advanced_mode = base_vars.advanced_mode %}
    {% set x_max = base_vars.grid_size %}
    {% set mdiff = x_max | float - 2 %}
    {% set nxy.sumxy = 0 | float %}
    {% set nxy.sumx2 = 0 | float %}
    {% set out_points= printer["gcode_macro LOG_PROBE"].outlist %}
	{% set n = out_points | count %}
	#M118 pts to tilt: {out_points}
    {% set sum_x = 0 | float %}
    {% set sum_y = 0 | float %}
	{% set sum_x = out_points | sum(attribute=0) | float %}
    {% set sum_y = out_points | sum(attribute=1) | float %}
    # Accumulate sums for  regression; a point is 2 element tuple
    # local variables re-defined in loops, do not persist outside of loop, and do not update in loops
    # use namespace variables to hold  variables that changes in loop is critical.
    M118 start calculation

    {% for point in out_points %}
        # for x add in the gap distance from left screw to G1 X0 nozzle start position
        {% set x = point[0] | float  %}
        {% set y = point[1] | float %}
        {% set xy = x * y | float %} 
        {% set nxy.sum_xy = nxy.sum_xy + xy %}
        {% set nxy.sum_x2 = nxy.sum_x2 | float + x*x | float %}
        #{% if x > mdiff %}
        #    M118 asum_x: {sum_x} asum_y: {sum_y} asum_xy: {nxy.sum_xy} asum_x2: {nx2.sum_x2}
        #    {% set m = (n * nxy.sum_xy - sum_x * sum_y) / (n * nx2.sum_x2 - sum_x * sum_x) %}
        #    {% set b = (sum_y - m * sum_x) / n %}
        #     Output the results
        #    M118 Slope: {m}, Intercept: {b}
        #{% endif %}
    #SET_GCODE_VARIABLE MACRO=Z_TILT VARIABLE=sum_xy VALUE= sumxy 
    #SET_GCODE_VARIABLE MACRO=Z_TILT VARIABLE=sum_x2 VALUE= sumx2
    {% endfor %}
    #M118 asum_x: {sum_x} asum_y: {sum_y} asum_xy: {nxy.sum_xy} asum_x2: {nxy.sum_x2}
    # Calculate slope (m) and intercept (b)
    {% set m = (n * nxy.sum_xy - sum_x * sum_y) / (n*nxy.sum_x2 - sum_x * sum_x) %}
    {% set b = (sum_y - m * sum_x) / n %}
    # Output the results
    M118 Slope: {m}, Intercept: {b}
   
    #screw adjuster. Based in part on the code from the Z_TRAMMING macro.
    #calculate the distance to move screw based on the slope between z axis screws. 
    #Left screw is designated as the zero reference point. 
	#tilt is right side - left side, pos. tilt means right bed side lower, because 
	#larger right side values = probe distance to bed greater than left side.
	#Therefore decrease distance between bed right side and nozzle, i.e., lower the gantry
	#Turn the screw CCW on right side. CW raises gantry increasing bed to nozzle difference
	#if slope positive and greater than tolerance, must decrease the nozzle to bed ditance 
	#on right side, turn CCW.
    #right side height at screw is m*z_scews_distance
	{% set tilt = m*z_screws_distance + b - b %} # mm variation between left and right Z screws.
    M118 tilt in mm is: {tilt} 
    {% if tilt > tolerance %} # right side too low
        {action_respond_info("--------------------------------------")}
        #{action_respond_info("01:20 means 1 full turn and 20 minutes, CW=clockwise, CCW=counter-clockwise")}
        #{% set hours = ((tilt) / pitch)|round(1, "floor")|int %}
        #{% set minutes = ((((tilt) / pitch)* 60) % 60)|round(1, "floor")|int %}
        {% set hours = ((tilt) / pitch)|int %}
        {% set minutes =  (((tilt / pitch) - hours) * 60) | round(1)  %}
        {action_respond_info("Turn the right lead screw:" ~ hours ~ ":" ~ minutes ~ " CCW")}
        {action_respond_info("Right is " ~ '%0.2f'| format(tilt|float) ~ " mm higher")}
        {% if printer["gcode_macro Z_TRAMMING_GRID"].advanced_mode == 1 %}
            SET_STEPPER_ENABLE STEPPER=stepper_z ENABLE=0
            M118 Stepper Z disabled
        {% else %}
           M18 #disable all steppers 
        {% endif %}
      	#{action_raise_error("Macro Stopped.")}
    {% elif tilt < tolerance * -1 %}
        {action_respond_info("--------------------------------------")}
        #{action_respond_info("01:20 means 1 full turn and 20 minutes, CW=clockwise, CCW=counter-clockwise")}
        {% set hours = ((-1*tilt) / pitch)|int %}
        {% set minutes =  (((-1*tilt / pitch) - hours) * 60) | round(1) %}
        #{% set hours = ((tilt) / pitch)|round(1, "floor")|int %}
        #{% set minutes = ((((tilt) / pitch)* 60) % 60)|round(1, "floor")|int %}
        {action_respond_info("Turn the right lead screw " ~ hours ~ ":" ~ minutes ~ " CW")}
        {action_respond_info("Right is " ~ '%0.2f'| format(tilt|float) ~ " mm lower")}
        {% if printer["gcode_macro Z_TRAMMING_GRID"].advanced_mode == 1 %}
            SET_STEPPER_ENABLE STEPPER=stepper_z ENABLE=0
            M118 Stepper Z disabled 
        {% else %}
          M18 #disable all steppers
        {% endif %}
     	#{action_raise_error("Macro Stopped.")}
    {% else %}
         M118 Bed is within tolerance set to {tolerance}, with tilt: {tilt} mm
        #{action_raise_error("Macro Stopped.")}        
    {% endif %} 
    #clean up for possible next cycle
    SET_GCODE_VARIABLE MACRO=Z_TRAMMING_GRID VARIABLE=x_position VALUE=0 
    SET_GCODE_VARIABLE MACRO=Z_TRAMMING_GRID VARIABLE=points VALUE=[]
    SET_GCODE_VARIABLE MACRO=LOG_PROBE VARIABLE=outlist VALUE=[]
    #{action_respond_info("01:20 means 1 full turn and 20 minutes, CW=clockwise, CCW=counter-clockwise")} 


[gcode_macro LOG_PROBE]
variable_probe_result: 0
variable_outlist: []

gcode:
        # set last z from PROBE in Z_tramming_grid to a local variable, but cannot be used elsewhere
		{% set probe_result = printer.probe.last_z_result %}
     	#M118 log_probe sees: {probe_result}
        {% set nx = 0 %}
        {% set base_vars = printer["gcode_macro Z_TRAMMING_GRID"] %}
       	{% set x_offset = base_vars.x_offset %}
        {% set x0 = base_vars.x_gap %}
        {% set x_pos = base_vars.x_position | float + x_offset | float + x0 | float %}
        {% set newpts = base_vars.points %}
        {% set x_pts = base_vars.x_points %}
        {% set y_pts = base_vars.y_points %}
        {% set total_pts = x_pts*y_pts | int %}
        {% set atuple = (x_pos, probe_result) %}
        # Add tuple to intermediate list
        {% if newpts %}
            {% set updated_list = newpts + [atuple] %}
        {% else %}
          {% set updated_list = [atuple] %}
        {% endif %}
        #M118 atuple is: {atuple} updated_list is: {updated_list}
    	SET_GCODE_VARIABLE MACRO=Z_TRAMMING_GRID VARIABLE=points VALUE="{updated_list}" 
        # works: M118 log_probe poins list is; {base_vars.points}
        # works{} M118 log_probe update list is; {updated_list}
        {% set nx = updated_list | count %}
        M118 probe point: {nx}, position: {x_pos}, logged as value: {probe_result}
         #Create sublists to calculate the individual rows
        {% if nx == total_pts %}
            {% set rng = (total_pts/x_pts) | int %}
            #M118 rng is: {rng}
            {% set i = 0 | int %}
            {% for i in range(rng) %}
              #{action_respond_info("--------------------------------------")}
              {% set istart = (i*x_pts) | int %}
              {% set iend = ((i + 1)*x_pts) | int %} 
            #   M118 istart: {istart} iend: {iend}
               {% if i == 0 %}
                    {% set iend = x_pts | int %} 
                    {% set list1 = updated_list[:iend] %}
               {% else %}
                    {% set list1 = updated_list[istart:iend] %}
               {% endif %}
                   M118 list to process: {list1}
                   SET_GCODE_VARIABLE MACRO=LOG_PROBE VARIABLE=outlist VALUE="{list1}" 
                   #{% set pstuff =printer["gcode_macro LOG_PROBE"].outlist %}
                   #M118 outlist {pstuff}  ???? shows []
               z_tilt
            {% endfor %}
        {% endif %}
        # below does not work to reset the lists to run a 2nd time
        # must reboot to rerun.
        #{% if nx > total_pts  %}
        #    M118 reset lists
        #    {% set updated_list = [] %}
        #    {% set updated_list = [atuple] %}
        #    {% set nx = updated_list | count %}
        #    M118 nx reset {nx}
        # {% endif %} 

[gcode_macro Z_TRAMMING_GRID]
# This set of macros is based in part on code from https://github.com/GatoMiopia/Klipper_Z_Tramming
# which was a great help in designing the code here.
# It differs substantially in how data is stored and manipulated.
variable_mainsail: 1              # if using mainsail
variable_x_points: 5              # probe readings/row ( between left offset and grid_size)  
variable_y_points: 3
variable_spacing: 20              # spacing between the Y rows around bed center
variable_grid_size: 220
variable_probe_result: 0
variable_x_position: 0            
variable_points: []              # list variable to use globally
variable_screw_pitch: 4
variable_x_gap: 52               # distance in mm from left screw to nozzle @ G1 X0:
#distance between screws:
variable_z_screws_distance: 325  # distance between screws in mm
variable_max_tolerance: 0.07
#for next see: https://github.com/GatoMiopia/Klipper_Z_Tramming/blob/main/README.md
# set to one allows disabling single axis, but Klipper loses knowledge of where extruder is
variable_advanced_mode: 0
variable_x_offset: 27            # default, but is obtained from printer.cfg
variable_y_offset: -20           # default, but is obtained from printer.cfg


gcode:
    # Define the grid boundaries
	#the x and y values have to be configured to where probe is.
	#Probe X limits min at 27 and max 183, i.e., nozzle X0 and nozzle 166 for symmetry
    {% if printer.configfile.settings.probe %}
        {% set x_offset = printer.configfile.settings.probe.x_offset | default(0) %}
        {% set y_offset = printer.configfile.settings.probe.y_offset | default(0) %}
    {% endif %}    
    #M118 Found printer offsets as X: {x_offset} Y: {y_offset}
	{% set min_x = 0 %}
    # two possible cases, get tilt for symmetrically probed points, or maximum allowed by probe
    # will use asymmetric maximum
    #{% set max_x = grid_size - 2*x_offset %} 
    {% set max_x = grid_size - x_offset %} 
    
    #Y axis nozzle on SV06 when Y nozzle specified as 0 is actually at 5 mm  into 220 mm space
    #Probe Y limits are probe at 110-10 = 100 and 120; set nozzle 100 + 5 + 20 = 125 and 145 
    {% set min_y = grid_size/2 - spacing - y_offset + 5  %}
    # Prepare to collect probe data
    # Loop through Y values
    {% for y_index in range(y_points) %}
        {% set y_position = min_y + (y_index * spacing) %}
        # Loop through X values
        #M118 X_POINTS2 {x_points}
        {% for x_index in range(x_points) %}
            {% set x_pos = min_x + ((max_x - min_x) * x_index) / (x_points - 1) %}
            SET_GCODE_VARIABLE MACRO=Z_TRAMMING_GRID VARIABLE=x_position VALUE={x_pos}
              G1 X{x_pos} Y{y_position}
			PROBE
			#probe value is not available at run time, must use a helper macro to get z value to list
            log_probe
            #needed mext because seems to lose knowledge of head status
			G1 Z10
        {% endfor %}
    {% endfor %}
    M118 DONE  
	#z_tilt
